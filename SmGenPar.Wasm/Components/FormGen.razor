@using Microsoft.AspNetCore.Components.Rendering
@using System.Collections
@using System.ComponentModel
@using System.Text.Json
@using SmGenPar.Logic.Reflection

<EditForm Model="@Model"
          OnSubmit="@OnSubmit"
          OnValidSubmit="@OnValidSubmit"
          OnInvalidSubmit="@OnInvalidSubmit">
    @(RenderForm())
    @ChildContent
</EditForm>

@code {

    [Parameter]
    public Dictionary<object, object?>? Result { get; set; }

    [Parameter]
    public object? Model { get; set; }

    [Parameter]
    public EventCallback OnSubmit { get; set; }

    [Parameter]
    public EventCallback OnValidSubmit { get; set; }

    [Parameter]
    public EventCallback OnInvalidSubmit { get; set; }

    [Parameter]
    public RenderFragment? ChildContent { get; set; }


    static Dictionary<object, object?> NewDict() => new();

    RenderFragment RenderForm() => builder =>
    {
        var type = Model?.GetType()!;
        foreach (var property in type.GetPropertiesCached()) {
            object? propertyValue = property.GetValue(Model) ?? Activator.CreateInstance(property.PropertyType);
            builder.OpenElement(0, "div");
            string id = property.Name;
            AddLabel(builder, id, id);
            Result ??= new();
            AddInput(builder, id, propertyValue, property.PropertyType, Result);
            builder.CloseElement();
        }
    };

    void AddLabel(RenderTreeBuilder builder, string id, string text)
    {
        builder.OpenElement(0, "label");
        builder.AddAttribute(1, "for", id);
        builder.AddContent(2, text);
        builder.CloseElement();
    }

    void AddInput(RenderTreeBuilder builder, object id, object? value, Type type,
                  Dictionary<object, object?> currentObject)
    {
        var typeCode = Type.GetTypeCode(type);

        void AddPropertyCallback(ChangeEventArgs args)
        {
            currentObject[id] = args.Value;
        }

        matchTypeCode:
        switch (typeCode) {
        case >= TypeCode.SByte and <= TypeCode.Decimal when!type.IsEnum:
            AddInputElement(builder, id, "number", AddPropertyCallback);
            return;
        case TypeCode.Boolean:
            AddInputElement(builder, id, "checkbox", AddPropertyCallback);
            return;
        case TypeCode.String:
            AddInputElement(builder, id, "text", AddPropertyCallback);
            return;
        case TypeCode.DateTime:
            AddInputElement(builder, id, "datetime-local", AddPropertyCallback);
            return;
        case TypeCode.Object:
            goto matchObject;
        }

        matchObject:
        switch (value) {
        case Enum:
            OpenSelectElement(builder, id, type.Name, AddPropertyCallback);
            foreach (object? item in Enum.GetValues(type)) {
                builder.OpenElement(0, "option");
                builder.AddAttribute(1, "value", item);
                builder.AddContent(2, item);
                builder.CloseElement();
            }
            builder.CloseElement();
            return;
        case null when Nullable.GetUnderlyingType(type) is {} underlyingType:
            type = underlyingType;
            typeCode = Type.GetTypeCode(type);
            value = Activator.CreateInstance(type);
            goto matchTypeCode;
        case DateTimeOffset or DateTime:
            AddInputElement(builder, id, "datetime-local", AddPropertyCallback);
            return;
        case Guid or string:
            AddInputElement(builder, id, "text", AddPropertyCallback);
            return;
        case TimeSpan or TimeOnly:
            AddInputElement(builder, id, "time", AddPropertyCallback);
            return;
        case DateOnly:
            AddInputElement(builder, id, "date", AddPropertyCallback);
            return;
        case IList array:
            var elementType = type.GetElementType() ?? typeof(object);
            currentObject = (Dictionary<object, object?>)
                currentObject.GetValueRefOrCreate(id, NewDict)!;
            int i = 0;
            foreach (object? item in array) {
                AddInput(builder, i, item, elementType, currentObject);
                i += 1;
            }
            return;
        default:
            currentObject = (Dictionary<object, object?>)
                currentObject.GetValueRefOrCreate(id, NewDict)!;

            var properties = type.GetPropertiesCached();
            foreach (var property in properties) {
                builder.OpenElement(0, "div");
                object? newValue = property.GetValue(value) ?? Activator.CreateInstance(property.PropertyType);
                AddLabel(builder, property.Name, property.Name);
                AddInput(builder, property.Name, newValue, property.PropertyType, currentObject);
                builder.CloseElement();
            }
            return;
        }
    }

    void OpenSelectElement(RenderTreeBuilder builder, object id, string text, Action<ChangeEventArgs>? callback = null)
    {
        builder.OpenElement(0, "select");
        builder.AddAttribute(1, "id", id);
        builder.AddAttribute(2, "onchange", callback);
        builder.AddAttribute(3, "value", "");
        builder.AddContent(4, text);
    }

    void AddInputElement(RenderTreeBuilder builder, object id, string type, Action<ChangeEventArgs>? callback = null)
    {
        builder.OpenElement(0, "input");
        builder.AddAttribute(1, "id", id);
        builder.AddAttribute(2, "type", type);
        builder.AddAttribute(3, "onchange", callback);
        builder.CloseElement();
    }

}